import * as t from "@babel/types";
import { ProtoType } from "@cosmology/types";
import { ProtoParseContext } from "../../context";
import { ToAminoJSONMethod } from "./index";
export declare const toAminoJSON: {
    scalar(args: ToAminoJSONMethod, valExpr?: t.Expression): t.ExpressionStatement;
    string(args: ToAminoJSONMethod): t.ExpressionStatement;
    double(args: ToAminoJSONMethod): t.ExpressionStatement;
    float(args: ToAminoJSONMethod): t.ExpressionStatement;
    bool(args: ToAminoJSONMethod): t.ExpressionStatement;
    number(args: ToAminoJSONMethod): t.ExpressionStatement;
    int32(args: ToAminoJSONMethod): t.ExpressionStatement;
    uint32(args: ToAminoJSONMethod): t.ExpressionStatement;
    sint32(args: ToAminoJSONMethod): t.ExpressionStatement;
    fixed32(args: ToAminoJSONMethod): t.ExpressionStatement;
    sfixed32(args: ToAminoJSONMethod): t.ExpressionStatement;
    long(args: ToAminoJSONMethod): t.ExpressionStatement;
    int64(args: ToAminoJSONMethod): t.ExpressionStatement;
    uint64(args: ToAminoJSONMethod): t.ExpressionStatement;
    sint64(args: ToAminoJSONMethod): t.ExpressionStatement;
    fixed64(args: ToAminoJSONMethod): t.ExpressionStatement;
    sfixed64(args: ToAminoJSONMethod): t.ExpressionStatement;
    protoType(args: ToAminoJSONMethod): t.ExpressionStatement;
    anyType(args: ToAminoJSONMethod): t.ExpressionStatement;
    type(args: ToAminoJSONMethod): t.ExpressionStatement;
    enum(args: ToAminoJSONMethod): t.ExpressionStatement;
    bytes(args: ToAminoJSONMethod): t.ExpressionStatement;
    duration(args: ToAminoJSONMethod): t.ExpressionStatement;
    timestamp(args: ToAminoJSONMethod): t.ExpressionStatement;
    timestampDate(args: ToAminoJSONMethod): t.ExpressionStatement;
    pubkey(args: ToAminoJSONMethod): t.ExpressionStatement;
    rawBytes(args: ToAminoJSONMethod): t.ExpressionStatement;
    wasmByteCode(args: ToAminoJSONMethod): t.ExpressionStatement;
    keyHash(args: ToAminoJSONMethod): (t.ExpressionStatement | t.IfStatement)[];
    array(args: ToAminoJSONMethod, expr: t.Expression): t.IfStatement;
};
export declare const arrayTypes: {
    scalar(): t.Identifier;
    string(args: ToAminoJSONMethod): t.Identifier | t.MemberExpression;
    double(): t.Identifier;
    float(): t.Identifier;
    bool(): t.Identifier;
    number(): t.Identifier;
    int32(): t.Identifier;
    uint32(): t.Identifier;
    sint32(): t.Identifier;
    fixed32(): t.Identifier;
    sfixed32(): t.Identifier;
    long(args: ToAminoJSONMethod): t.Expression;
    int64(args: ToAminoJSONMethod): t.Expression;
    uint64(args: ToAminoJSONMethod): t.Expression;
    sint64(args: ToAminoJSONMethod): t.Expression;
    fixed64(args: ToAminoJSONMethod): t.Expression;
    sfixed64(args: ToAminoJSONMethod): t.Expression;
    rawBytes(args: ToAminoJSONMethod): t.CallExpression;
    wasmByteCode(args: ToAminoJSONMethod): t.CallExpression;
    bytes(args: ToAminoJSONMethod): t.CallExpression;
    enum(): t.Identifier;
    anyType(args: ToAminoJSONMethod): t.ConditionalExpression;
    protoType(args: ToAminoJSONMethod): t.ConditionalExpression;
    type(args: ToAminoJSONMethod): t.ConditionalExpression;
};
export declare const toAminoMessages: {
    anyType(): (t.VariableDeclaration | t.ExpressionStatement | t.ReturnStatement)[];
    timestamp(context: ProtoParseContext, name: string, proto: ProtoType): t.ReturnStatement;
    duration(context: ProtoParseContext, name: string, proto: ProtoType): t.ReturnStatement;
};
